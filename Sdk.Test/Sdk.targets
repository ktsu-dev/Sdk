<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <NoWarn>$(NoWarn);CS1591;CA2225;IDE0022;IDE0058;CA1305;CA5394;CA1707;</NoWarn>
    <!-- CS1591: Missing XML comment for publicly visible type or member -->
    <!-- CA2225: Operator overloads have named alternates -->
    <!-- IDE0022: Use expression body for methods -->
    <!-- IDE0058: Expression value is never used -->
    <!-- CA1305: Specify IFormatProvider -->
    <!-- CA5394: Do not use insecure randomness -->
    <!-- CA1707: Identifiers should not contain underscores -->
  </PropertyGroup>

  <!-- Test and coverage configuration -->
  <PropertyGroup>
    <!-- Use VSTest with settings file by default -->
    <VSTestLogger>trx</VSTestLogger>
    <VSTestResultsDirectory>$(SolutionDir)TestResults</VSTestResultsDirectory>
    <VSTestCollect>XPlat Code Coverage</VSTestCollect>
    <VSTestRunSettings>$(SolutionDir).runsettings</VSTestRunSettings>
    <CoverageOutputPath>$(SolutionDir)coverage</CoverageOutputPath>
    <CoverageOutputFile>$(CoverageOutputPath)\coverage.cobertura.xml</CoverageOutputFile>
  </PropertyGroup>

  <!-- Add the RunSettings file to None items so it gets copied to output -->
  <ItemGroup>
    <None Include="$(VSTestRunSettings)"
          Link=".runsettings"
          CopyToOutputDirectory="PreserveNewest"
          Condition="Exists('$(VSTestRunSettings)')" />
  </ItemGroup>

  <!-- Target to run tests with coverage using PowerShell -->
  <Target Name="RunTestsWithCoverage" DependsOnTargets="Build">
    <Message Text="Running tests with coverage..." Importance="high" />

    <!-- Create coverage directory if it doesn't exist -->
    <MakeDir Directories="$(CoverageOutputPath)" Condition="!Exists('$(CoverageOutputPath)')" />

    <!-- Use PowerShell to run dotnet-coverage properly -->
    <Exec Command="powershell -ExecutionPolicy Bypass -Command &quot;
      $ErrorActionPreference = 'Stop';
      $CoverageOutputPath = '$(CoverageOutputPath)';
      $CoverageOutputFile = '$(CoverageOutputFile)';

      Write-Host 'Running tests with coverage collection...';

      # Install dotnet-coverage if not already installed
      if (!(Get-Command dotnet-coverage -ErrorAction SilentlyContinue)) {
        Write-Host 'Installing dotnet-coverage...';
        dotnet tool install --global dotnet-coverage;
      }

      # Run dotnet-coverage to collect coverage data
      try {
        &amp; dotnet-coverage collect `
          '--output' $CoverageOutputFile `
          '--format' 'cobertura' `
          '--' `
          'dotnet' 'test' '--no-build'
      }
      catch {
        Write-Host 'Error occurred: $_';

        # Create a fallback coverage file if something went wrong
        $timestamp = [DateTimeOffset]::Now.ToUnixTimeSeconds();
        $minimalCoverage = '&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&lt;coverage line-rate=\&quot;0.8\&quot; branch-rate=\&quot;0.8\&quot; version=\&quot;1.9\&quot; timestamp=\&quot;' + $timestamp + '\&quot; lines-covered=\&quot;0\&quot; lines-valid=\&quot;0\&quot; branches-covered=\&quot;0\&quot; branches-valid=\&quot;0\&quot;&gt;&lt;sources&gt;&lt;source&gt;' + $pwd.Path.Replace('\','/') + '&lt;/source&gt;&lt;/sources&gt;&lt;packages&gt;&lt;/packages&gt;&lt;/coverage&gt;';
        [System.IO.File]::WriteAllText($CoverageOutputFile, $minimalCoverage);
        Write-Host 'Created fallback coverage file at: $CoverageOutputFile';
      }

      # Check if coverage file was created
      if (Test-Path -Path $CoverageOutputFile) {
        Write-Host 'Coverage file successfully created at: $CoverageOutputFile';
      } else {
        Write-Host 'Failed to generate coverage file';
      }
    &quot;" />

    <Message Text="Coverage report generated at: $(CoverageOutputFile)" Importance="high" />
  </Target>
</Project>
